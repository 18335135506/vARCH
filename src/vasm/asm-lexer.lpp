/**/
%top{
#include "asm-parser.h"
#include <cstdlib>
#include <stack>
#include "IncludesTree.h"

using namespace std;
}

%s STRING_CONTEXT
%s COMMENT

%x PREPROC_STATE_INCLUDE_FILE

DIGIT     [0-9]
LETTER    [a-zA-Z]
PUNCT     [-!"#$%&'()*+,./:;<=>?@[\\\]^_`{|}~]
LETT_DIG  ({LETTER}|{DIGIT})
ID        {LETTER}{LETT_DIG}*
KEYBKEYS  ([ \t]|{LETT_DIG}|[-!#$%&'()*+,./:;<=>?@[\\\]^_`{|}~])

LABEL     \.{ID}\:
AT_LABEL  \@{ID}
TO_LABEL  \.{ID}

STK_PTR   SP
USTK_PTR  USP
DREG      R[1-8]
AREG      A[1-8]
TREG      T{DIGIT}*
SREG      SR

REGISTER  \%([RA][1-8]|[U]?SP)
ADDR_REG  r?\(([RA][1-8]|[U]?SP)\)

%option bison-bridge bison-locations noyywrap

%{

#define MAX_STR_CONST 256

char string_buf[MAX_STR_CONST];
char *string_buf_ptr;

int getRegNum(const char * str);
int getTempRegNum(const char * str, const TypeOfArgument& type);
void createRegArg(asm_arg *& arg, YYLTYPE *& loc, const char * str,
              const TypeOfArgument& type, const int& offset, const bool rel);
void createTempRegArg(asm_arg *& arg, YYLTYPE *& loc, const char * str,
              const TypeOfArgument& type, const bool rel);
void createConstIntArg(asm_arg *& arg, YYLTYPE *& loc, const int _val);
void createConstRealArg(asm_arg *& arg, YYLTYPE *& loc, const float _val);
void createSpecialRegArg(asm_arg *& arg, YYLTYPE *& loc,
              const enum Registers& reg);
void createSpecialAddrRegArg(asm_arg *& arg, YYLTYPE *& loc,
              const enum Registers& reg, const bool rel);

#define YY_USER_ACTION \
   do {\
      yylloc->first_column = yylloc->last_column;\
      yylloc->last_column += yyleng;\
      yylloc->fileNode = includesTree->getCurrent();\
   } while(0);

struct FileBuffer {
  YY_BUFFER_STATE buff;         /* saved buffer */
  FILE * infile;                /* current file descriptor */
};

stack<FileBuffer> includesStack;

const vector<string> * includeDirs = NULL;

IncludesTree * includesTree = NULL;

FILE *
openFile(const char * filename, const char *& path);

%}

%%

<INITIAL>{

^[ \t]*"#"[ \t]*include { BEGIN(PREPROC_STATE_INCLUDE_FILE); }

^[ \t]*"#"[ \t]*pragma { return PREPROC_PRAGMA; }

^[ \t]*"#"[ \t]*define { return PREPROC_DEFINE; }

<<EOF>>   { if(!closeIncludeFile(yylloc)) yyterminate(); }

\${DIGIT}+ {
            yylval->integer = atoi(yytext+1);
            return INTEGER;
          }
\$({DIGIT}+\.{DIGIT}*|.{DIGIT}+) {
            yylval->real = atof(yytext+1);
            return REAL;
          }

SLEEP|PUSHA|POPA|RET|RETEX|REBOOT|HALT|NOT|INCR|DECR|COMP2|LSH|RSH|STACK|PUSH|POP|JSR|JMP|IFJ|IFNJ|TCJ|TZJ|TOJ|TNJ|TSJ|MOV|ADD|MULT|SUB|DIV|QUOT|AND|OR|XOR|MMU|PUT|GET|EQ|LO|MO|LE|ME|NEQ|BPUT|BGET|IFEQJ|IFNEQJ|IFLOJ|IFMOJ|IFLEJ|IFMEJ {
            yylval->instruction = ISet.getIstr(yytext);
            return INSTRUCTION;
          }

\.int       return KEYWORD_INT;
\.long      return KEYWORD_LONG;
\.real      return KEYWORD_REAL;
\.char      return KEYWORD_CHAR;
\.string    return KEYWORD_STRING;
\.local     return KEYWORD_LOCAL;
\.global    return KEYWORD_GLOBAL;
\.function  return KEYWORD_FUNCTION;
\.end       return KEYWORD_END;

\>{DIGIT}   yylval->integer = atoi(yytext+1); return CONTENT_CONST;
{LABEL}     yytext[yyleng-1] = '\0'; yylval->label = yytext+1; return DEF_LABEL;
{TO_LABEL}  yylval->label = yytext+1; return CONTENT_LABEL;
{AT_LABEL}  yylval->label = yytext+1; return POSITION_LABEL;

\%{SREG} {
            createSpecialRegArg(yylval->arg, yylloc, STATE_REGISTER);
            return REGISTER;
          }
\%{STK_PTR} {
            createSpecialRegArg(yylval->arg, yylloc, STACK_POINTER);
            return REGISTER;
          }
\%{USTK_PTR} {
            createSpecialRegArg(yylval->arg, yylloc, USER_STACK_POINTER);
            return REGISTER;
          }
\%{DREG} {
            createRegArg(yylval->arg, yylloc, yytext+2, REG, 0, false);
            return REGISTER;
          }
\%{AREG} {
            createRegArg(yylval->arg, yylloc, yytext+2, REG, OFFSET_REGS,false);
            return REGISTER;
          }
\%{TREG} {
            createTempRegArg(yylval->arg, yylloc, yytext+2, REG, false);
            return REGISTER;
          }
\+\%{DREG} {
            createRegArg(yylval->arg, yylloc, yytext+3, REG_PRE_INCR,
                          0, false);
            return REGISTER;
          }
\+\%{AREG} {
            createRegArg(yylval->arg, yylloc, yytext+3, REG_PRE_INCR,
                          OFFSET_REGS, false);
            return REGISTER;
          }
\+\%{TREG} {
            createTempRegArg(yylval->arg, yylloc, yytext+3, REG_PRE_INCR,
                             false);
            return REGISTER;
          }
\-\%{DREG} {
            createRegArg(yylval->arg, yylloc, yytext+3, REG_PRE_DECR,
                          0, false);
            return REGISTER;
          }
\-\%{AREG} {
            createRegArg(yylval->arg, yylloc, yytext+3, REG_PRE_DECR,
                          OFFSET_REGS, false);
            return REGISTER;
          }
\-\%{TREG} {
            createTempRegArg(yylval->arg, yylloc, yytext+3, REG_PRE_DECR,
                             false);
            return REGISTER;
          }
\%{DREG}\+ {
            createRegArg(yylval->arg, yylloc, yytext+2, REG_POST_INCR,
                          0, false);
            return REGISTER;
          }
\%{AREG}\+ {
            createRegArg(yylval->arg, yylloc, yytext+2, REG_POST_INCR,
                          OFFSET_REGS, false);
            return REGISTER;
          }
\%{TREG}\+ {
            createTempRegArg(yylval->arg, yylloc, yytext+2, REG_POST_INCR,
                             false);
            return REGISTER;
          }
\%{DREG}\- {
            createRegArg(yylval->arg, yylloc, yytext+2, REG_POST_DECR,
                          0, false);
            return REGISTER;
          }
\%{AREG}\- {
            createRegArg(yylval->arg, yylloc, yytext+2, REG_POST_DECR,
                          OFFSET_REGS, false);
            return REGISTER;
          }
\%{TREG}\- {
            createTempRegArg(yylval->arg, yylloc, yytext+2, REG_POST_DECR,
                             false);
            return REGISTER;
          }

r?\({SREG}\) {
            createSpecialAddrRegArg(yylval->arg, yylloc, STATE_REGISTER,
                                    (*yytext) == 'r');
            return REGISTER;
          }
r?\({STK_PTR}\) {
            createSpecialAddrRegArg(yylval->arg, yylloc, STACK_POINTER,
                                    (*yytext) == 'r');
            return REGISTER;
          }
r?\({USTK_PTR}\) {
            createSpecialAddrRegArg(yylval->arg, yylloc, USER_STACK_POINTER,
                                    (*yytext) == 'r');
            return REGISTER;
          }
r?\({DREG}\) {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 3 : 2),
                          ADDR_IN_REG, 0, (*yytext) == 'r');
            return REGISTER;
          }
r?\({AREG}\) {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 3 : 2),
                          ADDR_IN_REG, OFFSET_REGS, (*yytext) == 'r');
            return REGISTER;
          }
r?\({TREG}\) {
            createTempRegArg(yylval->arg, yylloc,
                             yytext+((*yytext) == 'r' ? 3 : 2),
                             ADDR_IN_REG, (*yytext) == 'r');
            return REGISTER;
          }
\+r?\({DREG}\) {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 4 : 3),
                          ADDR_IN_REG_PRE_INCR, 0, (*yytext) == 'r');
            return REGISTER;
          }
\+r?\({AREG}\) {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 4 : 3),
                          ADDR_IN_REG_PRE_INCR, OFFSET_REGS, (*yytext) == 'r');
            return REGISTER;
          }
\+r?\({TREG}\) {
            createTempRegArg(yylval->arg, yylloc,
                             yytext+((*yytext) == 'r' ? 4 : 3),
                             ADDR_IN_REG_PRE_INCR, (*yytext) == 'r');
            return REGISTER;
          }
\-r?\({DREG}\) {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 4 : 3),
                          ADDR_IN_REG_PRE_DECR, 0, (*yytext) == 'r');
            return REGISTER;
          }
\-r?\({AREG}\) {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 4 : 3),
                          ADDR_IN_REG_PRE_DECR, OFFSET_REGS, (*yytext) == 'r');
            return REGISTER;
          }
\-r?\({TREG}\) {
            createTempRegArg(yylval->arg, yylloc,
                             yytext+((*yytext) == 'r' ? 4 : 3),
                             ADDR_IN_REG_PRE_DECR, (*yytext) == 'r');
            return REGISTER;
          }
r?\({DREG}\)\+ {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 3 : 2),
                          ADDR_IN_REG_POST_INCR, 0, (*yytext) == 'r');
            return REGISTER;
          }
r?\({AREG}\)\+ {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 3 : 2),
                          ADDR_IN_REG_POST_INCR, OFFSET_REGS, (*yytext) == 'r');
            return REGISTER;
          }
r?\({TREG}\)\+ {
            createTempRegArg(yylval->arg, yylloc,
                             yytext+((*yytext) == 'r' ? 3 : 2),
                             ADDR_IN_REG_POST_INCR, (*yytext) == 'r');
            return REGISTER;
          }
r?\({DREG}\)\- {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 3 : 2),
                          ADDR_IN_REG_POST_DECR, 0, (*yytext) == 'r');
            return REGISTER;
          }
r?\({AREG}\)\- {
            createRegArg(yylval->arg, yylloc, yytext+((*yytext) == 'r' ? 3 : 2),
                          ADDR_IN_REG_POST_DECR, OFFSET_REGS, (*yytext) == 'r');
            return REGISTER;
          }
r?\({TREG}\)\- {
            createTempRegArg(yylval->arg, yylloc,
                             yytext+((*yytext) == 'r' ? 3 : 2),
                             ADDR_IN_REG_POST_DECR, (*yytext) == 'r');
            return REGISTER;
          }

{ID}        yylval->id = yytext; return ID;

"/*"        BEGIN(COMMENT);

\" {
            string_buf_ptr = string_buf;
            BEGIN(STRING_CONTEXT);
          }

";".*\n|\n {
            yylloc->first_line++;
            yylloc->first_column = 1;
            yylloc->last_line++;
            yylloc->last_column = 1;
            return END_LINE;
          }

{DIGIT}+{ID} {
            fprintf( stderr, "Line %4d Lexing Error, forbidden symbol: '%s'\n",
                     yylloc->first_line, yytext );
            includesTree->printStderrCurrent();
            includesTree->printStderrStackIncludes();
            exit(1);
          }
[ \t]+      /* eat up whitespace */
,           return COMA;

. {
            fprintf( stderr, "Line %4d Lexing Error, unknown symbol: '%s'\n",
                     yylloc->first_line, yytext );
            includesTree->printStderrCurrent();
            includesTree->printStderrStackIncludes();
            exit(1);
          }
}

<PREPROC_STATE_INCLUDE_FILE>{

[ \t]+      /* eat up whitespace */

[\"<].+[\">] {
            char * newFileName = new char[yyleng-1];
            if (!newFileName) {
              fprintf( stderr,
                       "Line %4d include filename too long (%4d chars): %s\n",
                       yylloc->first_line, yyleng-2, yytext+1 );
              includesTree->printStderrCurrent();
              includesTree->printStderrStackIncludes();
              exit(1);
            }
            strncpy(newFileName, yytext+1, yyleng-2);
            newFileName[yyleng-2] = '\0';
            if(!openIncludeFile(newFileName, yylloc)) {
              fprintf( stderr, "Line %4d inexisting include file name: %s\n",
                       yylloc->first_line, newFileName );
              includesTree->printStderrCurrent();
              includesTree->printStderrStackIncludes();
              exit(1);
            }
            delete newFileName;

            yylloc->first_line = 1, yylloc->first_column = 1;
            yylloc->last_line = 1,  yylloc->last_column = 1;
            yylloc->fileNode = includesTree->getCurrent();

            BEGIN(INITIAL);
          }

.|\n      {
            fprintf( stderr, "Line %4d bad include line\n", yylloc->first_line);
            includesTree->printStderrCurrent();
            includesTree->printStderrStackIncludes();
            exit(1);
          }
}

<COMMENT>{

<<EOF>>   {
            fprintf( stderr, "End of file in comment\n" );
            includesTree->printStderrCurrent();
            includesTree->printStderrStackIncludes();
            exit(1);
          }

\n  {
            yylloc->first_line++;
            yylloc->first_column = 1;
            yylloc->last_line++;
            yylloc->last_column = 1;
            return END_LINE;
          }
"*/"        BEGIN(INITIAL);
.           /* eat up */
}

<STRING_CONTEXT>{

<<EOF>>   {
            fprintf( stderr, "End of file in string\n" );
            includesTree->printStderrCurrent();
            includesTree->printStderrStackIncludes();
            exit(1);
          }

\\n         *string_buf_ptr++ = '\n';
\\t         *string_buf_ptr++ = '\t';
\\r         *string_buf_ptr++ = '\r';
\\b         *string_buf_ptr++ = '\b';
\\f         *string_buf_ptr++ = '\f';

\\(.|\n) {
            *string_buf_ptr++ = yytext[0];
            *string_buf_ptr++ = yytext[1];
          }

[^\\\n\"]+ {
            char *yptr = yytext;
            while ( *yptr )
              *string_buf_ptr++ = *yptr++;
          }

\" {
            BEGIN(INITIAL);
            *string_buf_ptr = '\0';
            yylval->string = string_buf;
            return STRING;
          }
}

%%

int
getRegNum(const char * str)
{
  char * tempStr = strndup(str,1);
  int num = atoi(tempStr) -1;
  free(tempStr);
  return num;
}

int
getTempRegNum(const char * str, const TypeOfArgument& type)
{
  size_t len = strlen(str);

  switch (type) {
    case REG_POST_INCR:
    case REG_POST_DECR: {
      len -= 1;
      break;
    }
    case ADDR_POST_INCR:
    case ADDR_POST_DECR:
    case ADDR_IN_REG_POST_INCR:
    case ADDR_IN_REG_POST_DECR: {
      len -= 2;
      break;
    }
    default: {
      break;
    }
  }
  char * tempStr = strndup(str, len);
  int num = atoi(tempStr) -1;

  free(tempStr);
  return num;
}

void
createRegArg(asm_arg *& arg, YYLTYPE *& loc, const char * str,
             const TypeOfArgument& type, const int& offset, const bool rel)
{
  asm_immediate_arg * tempArg = new asm_immediate_arg(*loc);
  tempArg->relative = rel;
  tempArg->type = type;
  tempArg->content.val = getRegNum(str) + offset;
  arg = tempArg;
}

void
createTempRegArg(asm_arg *& arg, YYLTYPE *& loc, const char * str,
                  const TypeOfArgument& type, const bool rel)
{
  asm_immediate_arg * tempArg = new asm_immediate_arg(*loc);
  tempArg->relative = rel;
  tempArg->type = type;
  tempArg->content.val = getTempRegNum(str, type);
  tempArg->isTemp = true;
  arg = tempArg;
}

void
createSpecialRegArg(asm_arg *& arg, YYLTYPE *& loc, const enum Registers& reg)
{
  asm_immediate_arg * tempArg = new asm_immediate_arg(*loc);
  tempArg->type = REG;
  tempArg->content.regNum = reg;
  tempArg->relative = false;
  arg = tempArg;
}

void
createSpecialAddrRegArg(asm_arg *& arg, YYLTYPE *& loc,
                        const enum Registers& reg, const bool rel)
{
  asm_immediate_arg * tempArg = new asm_immediate_arg(*loc);
  tempArg->type = ADDR_IN_REG;
  tempArg->content.regNum = reg;
  tempArg->relative = rel;
  arg = tempArg;
}

void
createConstIntArg(asm_arg *& arg, YYLTYPE *& loc, const int _val)
{
  asm_immediate_arg * tempArg = new asm_immediate_arg(*loc);
  tempArg->type = COST;
  tempArg->content.val = _val;
  tempArg->relative = false;
  arg = tempArg;
}

void
createConstRealArg(asm_arg *& arg, YYLTYPE *& loc, const float _val)
{
  asm_immediate_arg * tempArg = new asm_immediate_arg(*loc);
  tempArg->type = COST;
  tempArg->content.fval = _val;
  tempArg->relative = false;
  arg = tempArg;
}

void
setIncludeDirs(const vector<string> * _dirs)
{
  includeDirs = _dirs;
}

FILE *
openFile(const char * filename, const char *& path)
{
  if (!includeDirs) {
    throw BasicException("Implementation Error: Not initialized 'IncludeDirs'");
  }

  FILE * infile = fopen(filename, "r");
  path = ".";

  for(size_t dir = 0; !infile && dir < includeDirs->size(); dir++) {
    const string & inclDir = (*includeDirs)[dir];
    infile = fopen( ( inclDir + '/' + filename).c_str(), "r");
    path = inclDir.c_str();
  }

  return infile;
}

bool
openFirstFile(const char * const _filename)
{
  FileBuffer buff;
  const char * filepath = ".";
  
  buff.infile = openFile(_filename, filepath);
  if(!buff.infile) {
    perror(_filename);
    return false;
  }

  includesTree = new IncludesTree(filepath, _filename);

  buff.buff = yy_create_buffer(buff.infile, YY_BUF_SIZE);
  yy_switch_to_buffer(buff.buff);

  includesStack.push(buff);
  
  return true;
}

bool
openIncludeFile(const char * const _filename, const YYLTYPE * loc)
{
  FileBuffer buff;
  const char * filepath = ".";
  
  buff.infile = openFile(_filename, filepath);
  if(!buff.infile) {
    perror(_filename);
    return false;
  }

  includesTree->enterIncludeOfCurrent(filepath, _filename, *loc);

  buff.buff = yy_create_buffer(buff.infile, YY_BUF_SIZE);
  yy_switch_to_buffer(buff.buff);

  includesStack.push(buff);
  
  return true;
}

bool
closeIncludeFile(YYLTYPE * loc)
{
  if(!includesStack.size()) {
    return false;
  }

  FileBuffer buff = includesStack.top();
  fclose(buff.infile);
  yy_delete_buffer(buff.buff);

  includesStack.pop();  
  if(!includesStack.size()) {
    return false;
  }

  buff = includesStack.top();
  yy_switch_to_buffer(buff.buff);
  
  *loc = includesTree->getCurrentInclusionPosition();
  includesTree->exitInclude();

  return true;
}

void
cleanParser()
{
  delete includesTree;
}



%code requires {
#ifndef IR_MID_PARSER_YPP
#define IR_MID_PARSER_YPP

#include "parser_definitions.h"
#include "IR/IR_LowLevel_ParserHelpers.h"
#include "AST_Mid/AST_Mid_Tree.h"
#include <string>

int yyparse(ASTM_Tree * ast_tree);

void setIncludeDirs(const vector<string> * _dirs);
bool openFirstFile(const char * const _filename);
bool openIncludeFile(const char * const _filename, const YYLTYPE * loc);
bool closeIncludeFile(YYLTYPE * loc);

void cleanParser();

#endif
}

%code top {
#include <cstdio>
#include "IR_Mid_parser.h"
#include "IncludesTree.h"

void yyerror (YYLTYPE *locp, ASTM_Tree * ast_tree, char const *);

/* Copy of the header generated by Flex
*/
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex \
               (YYSTYPE * yylval_param,YYLTYPE * yylloc_param );

#define YY_DECL int yylex \
               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param )
#endif /* !YY_DECL */
}

%locations
%define api.pure
%error-verbose
%parse-param {ASTM_Tree * ast_tree}

%union {
  int instruction;
  struct {
    const char * text;
    int len;
  } str;
  
  enum ASTM_BuiltinTypes type;
  enum ASTM_TypeQualifiers qualifier;

  struct ASTM_Arg *arg;
  struct ASTM_Stmt *stmt;
  struct ASTM_StmtExp *stmtExp;
  struct ASTM_StmtAssign *stmtAssign;
  struct ASTM_VarDecl *varDecl;

  struct ASTM_FunctionProto * functionProto;
  struct ASTM_FunctionDef * functionDef;
  struct ASTM_Param * parameter;

  list<ASTM_Stmt *>  * listOfStatements;
  list<ASTM_Param *>  * listOfParameters;
}

%token KEYWORD_I8 KEYWORD_I16 KEYWORD_I32 KEYWORD_I64
%token KEYWORD_U8 KEYWORD_U16 KEYWORD_U32 KEYWORD_U64
%token KEYWORD_F32 KEYWORD_F64 KEYWORD_VOID

%token KEYWORD_PTR_I8 KEYWORD_PTR_I16 KEYWORD_PTR_I32 KEYWORD_PTR_I64
%token KEYWORD_PTR_U8 KEYWORD_PTR_U16 KEYWORD_PTR_U32 KEYWORD_PTR_U64
%token KEYWORD_PTR_F32 KEYWORD_PTR_F64 KEYWORD_PTR_VOID

%token KEYWORD_CHAR KEYWORD_STRING

%token KEYWORD_CONST KEYWORD_SHARED KEYWORD_RELATIVE

%token ASSIGN_ARROW

%token <instruction> INSTRUCTION
%token <instruction> BITCAST_OP

%token <str> NUMBER
%token <str> STRING

%token <str> DEF_LABEL
%token <str> REF_LABEL
%token <str> REGISTER
%token <str> SPECIAL_REGISTER
%token <str> ID

%token PREPROC_DEFINE
%token PREPROC_PRAGMA

%type <type> type
%type <type> type_content
%type <type> type_pointer

%type <qualifier> type_qualifier

%type <arg> arg
%type <arg> register
%type <arg> register_content
%type <arg> register_pointer
%type <arg> register_relative_pointer

%type <stmt> stmt
%type <stmt> special_stmt
%type <stmtExp> instruction_stmt
%type <stmtAssign> assign_stmt
%type <varDecl> decl_stmt

%type <listOfStatements> stmt_block
%type <listOfStatements> stmt_list

%type <functionProto> function_decl
%type <functionDef> function_def

%type <parameter> param
%type <listOfParameters> params_list
%type <listOfParameters> decl_params

%%

program
      : /* empty file */
      | program block
      ;

block
      : function_decl { ast_tree->addFunctionProto( $1 ); }
      | function_def  { ast_tree->addFunctionDef( $1 ); }
      | decl_stmt ';' { ast_tree->addGlobalVar( $1 ); }
      | define
      | pragma
      ;

type
      : type_content  { $$ = $1; }
      | type_pointer  { $$ = $1; }
      ;
      
type_content
      : KEYWORD_I8        { $$ = ASTM_i8; }
      | KEYWORD_I16       { $$ = ASTM_i16; }
      | KEYWORD_I32       { $$ = ASTM_i32; }
      | KEYWORD_I64       { $$ = ASTM_i64; }
      | KEYWORD_U8        { $$ = ASTM_u8; }
      | KEYWORD_U16       { $$ = ASTM_u16; }
      | KEYWORD_U32       { $$ = ASTM_u32; }
      | KEYWORD_U64       { $$ = ASTM_u64; }
      | KEYWORD_F32       { $$ = ASTM_f32; }
      | KEYWORD_F64       { $$ = ASTM_f64; }
      | KEYWORD_VOID      { $$ = ASTM_void; }
      ;

type_pointer
      : KEYWORD_PTR_I8    { $$ = ASTM_ptr_i8; }
      | KEYWORD_PTR_I16   { $$ = ASTM_ptr_i16; }
      | KEYWORD_PTR_I32   { $$ = ASTM_ptr_i32; }
      | KEYWORD_PTR_I64   { $$ = ASTM_ptr_i64; }
      | KEYWORD_PTR_U8    { $$ = ASTM_ptr_u8; }
      | KEYWORD_PTR_U16   { $$ = ASTM_ptr_u16; }
      | KEYWORD_PTR_U32   { $$ = ASTM_ptr_u32; }
      | KEYWORD_PTR_U64   { $$ = ASTM_ptr_u64; }
      | KEYWORD_PTR_F32   { $$ = ASTM_ptr_f32; }
      | KEYWORD_PTR_F64   { $$ = ASTM_ptr_f64; }
      | KEYWORD_PTR_VOID  { $$ = ASTM_ptr_void; }
      ;

type_qualifier
      : KEYWORD_CONST     { $$ = ASTM_const; }
      | KEYWORD_SHARED    { $$ = ASTM_shared; }
      ;

stmt_block
      : '{' '}'           { $$ = new list<ASTM_Stmt *>(); }
      | '{' stmt_list '}' { $$ = $2; }
      ;

stmt_list
      : stmt            { $$ = new list<ASTM_Stmt *>();
                          $$->push_back( $1 ); }
      | stmt_list stmt  { $$ = $1; $$->push_back( $2 ); }
      ;

decl_params
      : '(' params_list ')'   { $$ = $2; }
      | '(' KEYWORD_VOID ')'  { $$ = new list<ASTM_Param *>(); }
      | '(' ')'               { $$ = new list<ASTM_Param *>(); }
      ;

params_list
      : params_list ',' param { $$ = $1; $$->push_back( $3 ); }
      | param                 { $$ = new list<ASTM_Param *>();
                                $$->push_back( $1 ); }
      ;

param
      : ID ':' type
                  { $$ = new ASTM_Param( yylloc, $3, string($1.text,$1.len) ); }
      ;

function_decl
      : type ASSIGN_ARROW ID decl_params ';'
                  { $$ = new ASTM_FunctionProto( yylloc, $1,
                                                 string($3.text, $3.len), $4); }
      ;

function_def
      : type ASSIGN_ARROW ID decl_params stmt_block
                  { $$ = new ASTM_FunctionDef( yylloc, $1,
                                             string($3.text, $3.len), $4, $5); }
      ;

stmt
      : decl_stmt ';'         { $$ = $1; }
      | assign_stmt ';'       { $$ = $1; }
      | instruction_stmt ';'  { $$ = $1; }
      | DEF_LABEL             
                  { $$ = new ASTM_StmtLabel( yylloc, string($1.text, $1.len)); }
      ;

decl_stmt
      : type_qualifier type assign_stmt
                  { $$ = new ASTM_VarDecl( yylloc, $1 == ASTM_const,
                                              $1 == ASTM_shared, $2, $3); }
      | type assign_stmt
                  { $$ = new ASTM_VarDecl( yylloc, false, false, $1, $2); }
      ;

assign_stmt
      : ID ASSIGN_ARROW instruction_stmt
                  { $$ = new ASTM_StmtAssign( yylloc, string($1.text, $1.len), $3); }
      | ID ASSIGN_ARROW special_stmt
                  { $$ = new ASTM_StmtAssign( yylloc, string($1.text, $1.len), $3); }
      | ID ASSIGN_ARROW arg
                  { $$ = new ASTM_StmtAssign( yylloc, string($1.text, $1.len), $3); }
      ;

arg
      : NUMBER    ':' type
                  { $$ = new ASTM_ArgNumber( yylloc, string($1.text, $1.len), $3 ); }
      | REF_LABEL ':' KEYWORD_RELATIVE
                  { $$ = new ASTM_ArgLabel( yylloc, string($1.text, $1.len), true ); }
      | REF_LABEL
                  { $$ = new ASTM_ArgLabel( yylloc, string($1.text, $1.len) ); }
      | register
                  { $$ = $1; }
      ;
      
register
      : register_content          { $$ = $1; }
      | register_pointer          { $$ = $1; }
      | register_relative_pointer { $$ = $1; }
      ;

register_content
      : REGISTER ':' type_content
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $3, REG ); }
      | '+' REGISTER ':' type_content
                  { $$ = new ASTM_ArgRegister( yylloc, $2.text, $4, REG_PRE_INCR ); }
      | '-' REGISTER ':' type_content
                  { $$ = new ASTM_ArgRegister( yylloc, $2.text, $4, REG_PRE_DECR ); }
      | REGISTER '+' ':' type_content
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $4, REG_POST_INCR ); }
      | REGISTER '-' ':' type_content
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $4, REG_POST_DECR ); }
      ;

register_pointer
      : REGISTER ':' type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $3, ADDR_IN_REG ); }
      | '+' REGISTER ':' type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $2.text, $4, ADDR_IN_REG_PRE_INCR ); }
      | '-' REGISTER ':' type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $2.text, $4, ADDR_IN_REG_PRE_DECR ); }
      | REGISTER '+' ':' type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $4, ADDR_IN_REG_POST_INCR ); }
      | REGISTER '-' ':' type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $4, ADDR_IN_REG_POST_DECR ); }
      ;

register_relative_pointer
      : REGISTER ':' KEYWORD_RELATIVE type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $4, ADDR_IN_REG, true ); }
      | '+' REGISTER ':' KEYWORD_RELATIVE type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $2.text, $5, ADDR_IN_REG_PRE_INCR, true ); }
      | '-' REGISTER ':' KEYWORD_RELATIVE type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $2.text, $5, ADDR_IN_REG_PRE_DECR, true ); }
      | REGISTER '+' ':' KEYWORD_RELATIVE type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $5, ADDR_IN_REG_POST_INCR, true ); }
      | REGISTER '-' ':' KEYWORD_RELATIVE type_pointer
                  { $$ = new ASTM_ArgRegister( yylloc, $1.text, $5, ADDR_IN_REG_POST_DECR, true ); }
      ;

instruction_stmt
      : instruction_stmt ',' arg  { $$ = $1; $1->addArg( $3 ); }
      | INSTRUCTION ':' type      { $$ = new ASTM_StmtExp( yylloc, $1, $3 ); }
      | INSTRUCTION               { $$ = new ASTM_StmtExp( yylloc, $1 ); }
      ;

special_stmt
      : BITCAST_OP ':' type ',' arg
                  { $$ = new ASTM_StmtSpecialExp( yylloc, $1, $3, $5 ); }
      ;

define
      : PREPROC_DEFINE ID NUMBER
      ;

pragma
      : PREPROC_PRAGMA
      ;

%%

void
yyerror (YYLTYPE *locp, ASTM_Tree * ast_tree, char const *s)
{
  fprintf( stderr, "SYNTHAX ERROR: %s\n", s );
  fprintf( stderr, "   at line: %4d col: %4d\n", locp->first_line,
           locp->first_column);
  locp->fileNode->printStderr();
  locp->fileNode->printStderrStackIncludes();
}



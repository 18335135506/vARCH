%code requires {
#ifndef ASM_PARSER_YPP
#define ASM_PARSER_YPP

#include "parser_definitions.h"
#include "asm-classes.h"
#include "asm-program.h"
#include "asm-function.h"

int yyparse(asm_program * program);

void setIncludeDirs(const vector<string> * _dirs);
bool openFirstFile(const char * const _filename);
bool openIncludeFile(const char * const _filename, const YYLTYPE * loc);
bool closeIncludeFile(YYLTYPE * loc);

void cleanParser();

#endif
}

%code top {
#include <cstdio>
#include "asm-parser.h"
#include "IncludesTree.h"

void yyerror (YYLTYPE *locp, asm_program * program, char const *);

/* Copy of the header generated by Flex
*/
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex \
               (YYSTYPE * yylval_param,YYLTYPE * yylloc_param );

#define YY_DECL int yylex \
               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param )
#endif /* !YY_DECL */
}

%locations
%define api.pure
%error-verbose
%parse-param {asm_program * program}

%union {
  char *string;
  int integer;
  float real;
  int instruction;
  char *id;
  char *label;

  struct asm_arg *arg;
  struct asm_statement *stmt;
  struct asm_instruction_statement *instr_stmt;
  struct asm_data_statement *data_stmt;
  struct asm_data_keyword_statement *keyw_stmt;
  struct asm_function *function;
  struct asm_function_param *function_parameter;

  list<asm_statement *>  * listOfStatements;
  list<asm_data_statement *>  * listOfDataStatements;
}

%token <integer> INTEGER
%token <integer> CONTENT_CONST
%token <real> REAL
%token <string> STRING
%token <instruction> INSTRUCTION
%token KEYWORD_INT KEYWORD_LONG KEYWORD_REAL KEYWORD_CHAR KEYWORD_STRING
%token KEYWORD_LOCAL KEYWORD_GLOBAL KEYWORD_FUNCTION KEYWORD_END KEYWORD_PARAM
%token <label> DEF_LABEL
%token <label> POSITION_LABEL
%token <label> CONTENT_LABEL
%token <arg> REGISTER
%token <arg> TEMPORARY
%token <id> ID
%token COMA
%token END_LINE

%token PREPROC_DEFINE
%token PREPROC_PRAGMA

%type <arg> arg
%type <stmt> stmt
%type <instr_stmt> instruction_stmt
%type <data_stmt> data_stmt
%type <keyw_stmt> data_keyword
%type <listOfDataStatements> data_stmts
%type <listOfDataStatements> locals
%type <listOfDataStatements> globals

%type <function> function
%type <function> function_init_and_body
%type <function> function_init_all
%type <function> function_init_params
%type <function> function_init

%type <function_parameter> function_parameter

%%

program
      : block
      ;

block
      : block blank_lines block
      | function     { program->addFunction( $1 ); }
      | globals      { program->addGlobals( $1 ); }
      | define
      | pragma
      | 
      ;

globals
      : KEYWORD_GLOBAL blank_lines data_stmts blank_lines KEYWORD_END
                  { $$ = $3; }
      | KEYWORD_GLOBAL blank_lines KEYWORD_END
                  { $$ = new list<asm_data_statement *>(); }
      ;

blank_lines
      : blank_lines END_LINE
      | END_LINE
      ;



function
      : function_init_and_body KEYWORD_END
                  { $1->finalize(); $$ = $1; }
      ;

function_init_and_body
      : function_init_and_body stmt
                  { $1->addStmt( $2 ); $$ = $1; }
      | function_init_all
                  { $$ = $1; }
      ;

function_init_all
      : function_init_all locals
                  { $1->addLocals( $2 ); delete $2; $$ = $1; }
      | function_init_params
                  { $$ = $1; }
      ;

function_init_params
      : function_init_params function_parameter
                  { $1->addParameter( $2 ); $$ = $1; }
      | function_init
                  { $$ = $1; }
      ;

function_init
      : KEYWORD_FUNCTION STRING blank_lines
                  { $$ = new asm_function( yylloc, $2 ); }
      ;

function_parameter
      : KEYWORD_PARAM REGISTER blank_lines
                  { $$ = new asm_function_param( yylloc, $2 ); delete $2; }
      ;


locals
      : KEYWORD_LOCAL blank_lines data_stmts blank_lines KEYWORD_END blank_lines
                  { $$ = $3; }
      | KEYWORD_LOCAL blank_lines KEYWORD_END blank_lines
                  { $$ = new list<asm_data_statement *>(); }
      ;



arg
      : INTEGER         { $$ = new asm_immediate_arg( yylloc, $1 , COST ); }
      | CONTENT_CONST   { $$ = new asm_immediate_arg( yylloc, $1 , ADDR ); }
      | REAL            { $$ = new asm_immediate_arg( yylloc, $1 ); }
      | POSITION_LABEL  { $$ = new asm_label_arg( yylloc, $1 , COST ); }
      | CONTENT_LABEL   { $$ = new asm_label_arg( yylloc, $1 , ADDR ); }
      | REGISTER        { $$ = $1; }
      | TEMPORARY       { $$ = $1; }
      ;

stmt
      : instruction_stmt blank_lines  { $$ = $1; }
      | data_stmt blank_lines         { $$ = $1; }
      ;

instruction_stmt
      : instruction_stmt arg  { $$ = $1->addArg( $2 ); }
      | INSTRUCTION
                  { $$ = new asm_instruction_statement( yylloc, $1 ); }
      ;

data_stmts
      : data_stmts blank_lines data_stmt
                  { $1->push_back( $3 ); $$ = $1; }
      | data_stmt { $$ = new list<asm_data_statement *>();
                    $$->push_back( $1 ); }
      | error blank_lines data_stmt
                  { $$ =  new list<asm_data_statement *>();
                    $$->push_back( $3 ); }
      ;

data_stmt
      : DEF_LABEL     { $$ = new asm_label_statement( yylloc, $1 ); }
      | data_keyword  { $$ = $1; }
      ;

data_keyword
      : KEYWORD_INT INTEGER 
                  { $$ = new asm_int_keyword_statement( yylloc, $2 ); }
      | KEYWORD_LONG INTEGER
                  { $$ = new asm_long_keyword_statement( yylloc, $2 ); }
      | KEYWORD_REAL REAL
                  { $$ = new asm_real_keyword_statement( yylloc, $2 ); }
      | KEYWORD_CHAR ID
      	          { $$ = new asm_char_keyword_statement( yylloc, $2 ); }
      | KEYWORD_STRING STRING
                  { $$ = new asm_string_keyword_statement( yylloc, $2 ); }
      ;

define
      : PREPROC_DEFINE ID CONTENT_CONST
      ;

pragma
      : PREPROC_PRAGMA
      ;

%%

void
yyerror (YYLTYPE *locp, asm_program * program, char const *s)
{
  fprintf( stderr, "ASSEMBLER ERROR: %s\n", s );
  fprintf( stderr, "   at line: %4d col: %4d\n", locp->first_line,
           locp->first_column);
  locp->fileNode->printStderr();
  locp->fileNode->printStderrStackIncludes();
}



%code requires {
#ifndef IR_MID_PARSER_YPP
#define IR_MID_PARSER_YPP

#include "parser_definitions.h"
/*#include "IR/IR_LowLevel_ParserHelpers.h"*/
#include "AST/AST_Low/AST_Low_Tree.h"
#include <string>

int yyparse(ASTL_Tree * ast_tree);

void setIncludeDirs(const vector<string> * _dirs);
bool openFirstFile(const char * const _filename);
bool openIncludeFile(const char * const _filename, const YYLTYPE * loc);
bool closeIncludeFile(YYLTYPE * loc);

void cleanParser();

#endif
}

%code top {
#include <cstdio>
#include "IR_Low_parser.h"
#include "IncludesTree.h"

void yyerror (YYLTYPE *locp, ASTL_Tree * ast_tree, char const *);

/* Copy of the header generated by Flex
*/
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex \
               (YYSTYPE * yylval_param,YYLTYPE * yylloc_param );

#define YY_DECL int yylex \
               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param )
#endif /* !YY_DECL */
}

%locations
%define api.pure
%error-verbose
%parse-param {ASTL_Tree * ast_tree}

%union {
  int instruction;
  struct {
    const char * text;
    size_t len;
  } str;

  enum Registers special_reg;

  enum ScaleOfArgument type;
  enum ASTL_TypeQualifiers qualifier;

  struct ASTL_Arg *arg;
  struct ASTL_ArgRegister *arg_reg;
  struct ASTL_Stmt *stmt;
  struct ASTL_StmtLabel *stmtLab;
  struct ASTL_StmtExp *stmtExp;
  struct ASTL_StmtAssign *stmtAssign;

  struct ASTL_FunctionDef * function;
  struct ASTL_Param * function_parameter;

  list<ASTL_Stmt *>  * listOfStatements;
  list<ASTL_Param *>  * listOfParameters;
}

%token KEYWORD_I8 KEYWORD_I16 KEYWORD_I32 KEYWORD_I64

%token KEYWORD_REAL KEYWORD_STRING
%token KEYWORD_CONST KEYWORD_SHARED
%token KEYWORD_LOCAL KEYWORD_GLOBAL KEYWORD_FUNCTION KEYWORD_END KEYWORD_PARAM

%token END_LINE

%token <instruction> INSTRUCTION
%token <instruction> BITCAST_OP

%token <str> NUMBER
%token <str> STRING

%token <str> ID
%token <str> DEF_LABEL
%token <str> REF_AT_LABEL
%token <str> REF_TO_LABEL
%token <str> REGISTER
%token <special_reg> SPECIAL_REGISTER

%token PREPROC_DEFINE

%type <type> type

%type <qualifier> type_qualifier

%type <arg> arg
%type <arg_reg> register
%type <arg_reg> register_mod
%type <arg_reg> register_addressing

%type <stmt> stmt
%type <stmt> data_stmt
%type <stmtLab> label_def
%type <stmtExp> instruction_stmt

%type <listOfStatements> locals
%type <listOfStatements> globals
%type <listOfStatements> data_stmt_list

%type <function> function
%type <function> function_init_and_body
%type <function> function_init_all
%type <function> function_init_params
%type <function> function_init

%type <function_parameter> function_parameter

%%

program
      : /* empty file */
      | program block
      ;

block
      : function      { ast_tree->addFunctionDef( $1 ); }
      | globals       { ast_tree->addGlobalVars( $1 ); delete $1; }
      | define
      | blank_lines
      ;

globals
      : KEYWORD_GLOBAL blank_lines data_stmt_list KEYWORD_END
                  { $$ = $3; }
      | KEYWORD_GLOBAL blank_lines KEYWORD_END
                  { $$ = new list<ASTL_Stmt *>(); }
      ;

blank_lines
      : blank_lines END_LINE
      | END_LINE
      ;

type_qualifier
      : KEYWORD_CONST     { $$ = ASTL_const; }
      | KEYWORD_SHARED    { $$ = ASTL_shared; }
      ;


data_stmt_list
      : data_stmt                 { $$ = new list<ASTL_Stmt *>();
                                    $$->push_back( $1 ); }
      | data_stmt_list data_stmt  { $$ = $1; $$->push_back( $2 ); }
      ;



function
      : function_init_and_body KEYWORD_END
                  { $1->finalize(); $$ = $1; }
      ;

function_init_and_body
      : function_init_and_body stmt
                  { $1->addStmt( $2 ); $$ = $1; }
      | function_init_all
                  { $$ = $1; }
      ;

function_init_all
      : function_init_all locals
                  { $1->addLocals( $2 ); delete $2; $$ = $1; }
      | function_init_params
                  { $$ = $1; }
      ;

function_init_params
      : function_init_params function_parameter
                  { $1->addParameter( $2 ); $$ = $1; }
      | function_init
                  { $$ = $1; }
      ;

function_init
      : KEYWORD_FUNCTION STRING blank_lines
                  { $$ = new ASTL_FunctionDef( yylloc, string($2.text, $2.len) ); }
      ;

function_parameter
      : KEYWORD_PARAM REGISTER REGISTER blank_lines
                  { $$ = new ASTL_Param( yylloc, string($2.text, $2.len), string($3.text, $3.len) ); }
      ;


locals
      : KEYWORD_LOCAL blank_lines data_stmt_list KEYWORD_END blank_lines
                  { $$ = $3; }
      | KEYWORD_LOCAL blank_lines KEYWORD_END blank_lines
                  { $$ = new list<ASTL_Stmt *>(); }
      ;


data_stmt
      : label_def blank_lines
                  { $$ = $1; }
      | type NUMBER blank_lines
                  { $$ = new ASTL_VarDeclNumber(yylloc, $1, new ASTL_ArgNumber( yylloc, string($2.text, $2.len) ) ); }
      | KEYWORD_STRING STRING blank_lines
                  { $$ = new ASTL_VarDeclString(yylloc, string($2.text, $2.len) ); }
      | KEYWORD_REAL NUMBER blank_lines
                  { $$ = new ASTL_VarDeclFloat(yylloc, new ASTL_ArgNumber( yylloc, string($2.text, $2.len) ) ); }
      ;

stmt
      : instruction_stmt blank_lines  { $$ = $1; }
      | label_def blank_lines         { $$ = $1; }
      ;

label_def
      : type_qualifier label_def
                  { $$ = $2; $$->addQualifier($1); }
      | DEF_LABEL { $$ = new ASTL_StmtLabel( yylloc, string($1.text, $1.len)); }
      ;

instruction_stmt
      : instruction_stmt ',' arg  { $$ = $1; $1->addArg( $3 ); }
      | INSTRUCTION               { $$ = new ASTL_StmtExp( yylloc, $1 ); }
      ;

type
      : KEYWORD_I8        { $$ = BYTE1; }
      | KEYWORD_I16       { $$ = BYTE2; }
      | KEYWORD_I32       { $$ = BYTE4; }
      | KEYWORD_I64       { $$ = BYTE8; }
      ;

arg
      : NUMBER    { $$ = new ASTL_ArgNumber( yylloc, string($1.text, $1.len) ); }
      | '(' NUMBER ')'
                  { $$ = new ASTL_ArgNumber( yylloc, string($2.text, $2.len), DIRECT ); }
      | REF_AT_LABEL
                  { $$ = new ASTL_ArgLabel( yylloc, string($1.text, $1.len), IMMED ); }
      | REF_TO_LABEL
                  { $$ = new ASTL_ArgLabel( yylloc, string($1.text, $1.len), DIRECT ); }
      | register_mod
                  { $$ = $1; }
      | arg ':' type
                  { $$ = $1; $1->scale = $3; }
      ;
      
register_mod
      : register_addressing          { $$ = $1; $$->modif = REG_NO_ACTION; }
      | '+' register_addressing      { $$ = $2; $$->modif = REG_PRE_INCR; }
      | '-' register_addressing      { $$ = $2; $$->modif = REG_PRE_DECR; }
      | register_addressing '+'      { $$ = $1; $$->modif = REG_POST_INCR; }
      | register_addressing '-'      { $$ = $1; $$->modif = REG_POST_DECR; }
      ;

register_addressing
      : register  { $$ = $1; $$->kind = REG; }
      | '(' register ')'
                  { $$ = $2; $$->kind = REG_INDIR; }
      | '(' '(' register ')' ')'
                  { $$ = $3; $$->kind = MEM_INDIR; }
      | NUMBER '(' register ')'
                  { $$ = $3; $$->kind = DISPLACED;
                    $$->displ = new ASTL_ArgNumber( yylloc, string($1.text, $1.len) ); }
      | '(' register ')' '[' register ']'
                  { $$ = $2; $$->kind = INDEXED;
                    $$->index = $5; $5->kind = REG_INDIR; }
      | NUMBER '(' register ')' '[' register ']'
                  { $$ = $3; $$->kind = INDX_DISP;
                    $$->index = $6; $6->kind = REG_INDIR;
                    $$->displ = new ASTL_ArgNumber( yylloc, string($1.text, $1.len) ); }
      ;

register
      : REGISTER  { $$ = new ASTL_ArgRegister( yylloc, string($1.text, $1.len) ); }
      | SPECIAL_REGISTER
                  { $$ = new ASTL_ArgSpecialRegister( yylloc, $1 ); }
      ;

define
      : PREPROC_DEFINE ID NUMBER
      ;

%%

void
yyerror (YYLTYPE *locp, ASTL_Tree * ast_tree, char const *s)
{
  fprintf( stderr, "SYNTHAX ERROR: %s\n", s );
  fprintf( stderr, "   at line: %4d col: %4d\n", locp->first_line,
           locp->first_column);
  locp->fileNode->printStderr();
  locp->fileNode->printStderrStackIncludes();
}



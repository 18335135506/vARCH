Index
1. COMPILE / INSTALL
2. WHAT IS IT
3. ASSEMBLY (two examples)
  3.1 BRIEF DESCRIPTION
  3.2 SUBROUTINES
  3.3 CONSTANTS
  3.4 PREPROCESSOR
4. NEW DEVELOPMENT
  4.1 TEMORARIES / Registers Auto-allocation
  4.2 CALLING CONVENTIONS
  4.3 SAMPLE FILES

--------------------------------------------------------------------------------
1. COMPILE / INSTALL

Before trying to compile it, remeber to run autoreconf.

Then it will be sufficient to type
./configure
make

I'm not providing a predefined install way right now. It's more like a toy, than
a tool.

--------------------------------------------------------------------------------
2. WHAT IS IT

vARCH is a virtual machine / interpreter of bytecode for a virtual architecture
that I invented for learning purposes.
It's not intended for performance or flexibility use cases. It's just a simple
and easy to learn architecture.

For the ease of development I also created a simple assembler and it should
offer some facility, over the "directly write binary code" :)
Explanation on how to write the asm code is aided by some practical examples.

If you want to contribute to vARCH, you should ask for documentation/answers to
me directly, because it is a spare time project and I don't have much time for
documentation.

What I will report here are samples of the Asm language: they need to be
assembled and then either moved to the name "bios.bin" or soft link the binary
to that name.

--------------------------------------------------------------------------------
3. ASSEMBLY

The first example is a simple program for calculating the first n factorials.
The "main" function is a special one that is always put at the beginning of the
binary

biosFactorial.s
----------------

; calculate the factorial by definition of the first 5 numbers
.function "main"
.init:
    MOV	  $1    %R8
.start:
; the counter is post incremented after the copy
    MOV   %R8+  %R1
    MOV   $1    %R2
.iter:
    MULT  %R1-  %R2
    MO    %R1   $1
    IFNJ  @save
    JMP   @iter
.save:
    PUSH  %R2
    MO    %R8   .maxnum
    IFJ   @end
    JMP   @start
.end:
    HALT
.end

.global
  .maxnum:
    .int  $12
.end

--------------------------------
Another simple program that shows how to give shape to subroutines.
Arguments passing is quite broken, but it's not the purpose of the example.
It also exploits a missing feature to ease the work of outputting text: it
should launch the signal to the peripheral and than wait for the ready state,
before sending another character to display, but it's just pretending that a
terminal can work syncronously with the cpu.

----------------
biosSubroutine.s
----------------

#include "biosGlobals.s"

.function   "main"
.local
.end
.init:
    MOV     @string1    %R1
; prepare destination comand
    MOV     .printCmd   %R2
    ADD     $1          %R2
.testCond:
    EQ      (R1)        .endChar
    IFJ     @end
; push the char to print on the stack
    PUSH    (R1)
; call the printing subroutine
    JSR     @print
; rebase stack pointer, since the pushed value is no more useful
    SUB     $1          %SP
    ADD     $1          %R1
    JMP     @testCond
.end:
    HALT
.end

.global
  .uselessGlobal:
    .int        $4
.end

; subroutine to call
.function   "print"
.local
  .stckPosArg:
    .int    $3
.end
; let's push the regs we're going to use
    PUSH    %R1
; get the stack pointer
    MOV     %SP         %R1
; point to the argument passed on the stack
    SUB     .stckPosArg %R1
    PUT     (R1)        %R2
; pop regs back
    POP     %R1
    RET
.end

----------------
biosGlobals.s
----------------

.global
  .printCmd:
    .int        $131072
  ; string to write
  .string1:
    .string     "prova yeah"
    .int        $10
    .int        $13
  .endChar:
    .int        $13
.end

-----------------------------------
BRIEF DESCRIPTION OF EXAMPLES:

There are 8 data registers R1, R2, .. , R8, and 8 general purpose address
registers A1, A2, .. , A8. Then a specific register for the stack pointer SP,
and USP for the priviledged executor that wants to access unprivileged stack
pointer. (Issuing SP when privileged, an issuing SP when unprivileged gives two
different stack pointers)

As noted here before, there are two kinds of execution: privileged and
unprivileged. The bit identifying this is in the status register ( SR ).
This is inspired to M68k.

Accessing data and registers is achieved in many ways with different meanings:

- prefixing registers with % (eg. %R1, %A3, %SP ..) which accessed the content
of the registers.

- surrounding registers with round parenthesis ( and ), (eg. (A1), (SP) ..)
which accesses the address in memory, pointed by the content of the register.

- using . (dot) prefixed labels which accesses the content of the address in
memory marked by the label.

- using @ (at) prefixed labels which accesses the pointer to the label.

- prefixing constants with $ which uses those as numerical constants

- prefixing constants with > which uses them as addresses (and addresses the
memory address pointed by the constant)

There are then other useful methods for reducing code size and speeding up
execution with a compact code:

- prefixing (or postfixing) registers with + or - which in turn pre(post)
increments or decrements the accessed data:
  + if prefixing with %Reg# it will modify the content of the register
  + if prefixing with (Reg#) it will still modify the register content (and not
     of the pointed data)
  + if doing this on (address), data pointed by the address will be modified

- putting a lowercase  r  before registers access, and if present, after pre
increment/decrement signs (eg. right: r%R2 , r(A5), +r(R4) .. , wrong: r+(A2),
%rR1, .. ), which refers the addresses or numbers as relative to the stack
pointer position. 

------------------
Some words about SUBROUTINES:

I implemented a specific way of instructing the assembler about subroutines, you
need to specify subroutine name after the  .function  marker, and specify end of
the subroutine with  .end  marker. The name of the subroutine needs to be
enclosed in double quotes, like a normal string.

There is no possibility to use free code, outside of subroutines, since the main
subroutine serves as entry point for the binary.

Subroutines, when assembled do export their name as a global label and they can
be accessed through . and @ facilities.
To call a subroutine just issue a

	JSR	@name_of_subroutine
Since JSR stands for "Jump to SubRoutine".

------------------
Some words about VARIABLES and CONSTANTS:

The  .global  marker opens the area where global/public constants should be
located. This area is terminated with an  .end  marker.
Variables or constants, are there visible from everywhere.

It's possible to specify local/private constants for function calls only after
the marker  .local  which is terminated by the  .end  marker, just like
functions and globals.
To specify access to these memory locations, it is also possible to use the
.shared  specifier, which behaves exactly like in C.
To optimize things,  .const  declared memory locations, are allocated like
shared variables, to prevent stack allocation at every function call.

Local variables on the stack are supported just with the register
auto-allocation logic, because it requires some code transformation.

Labels make data visible and easily callable from outside.

------------------
Some words about PREPROCESSOR:

As can be seen from the example, it is possible to include code from other files
and compile it as if it was part of the current source.

If any error happens in the included files, it will be reported in which file
and at which line the error took place.

------------------
4. THINGS BEING IMPLEMENTED (WORK IN PROGRESS)

4.1 - TEMPORARIES

The edge of development is now on register auto-allocation logics.
There is going to be a new kind of registers: T[0-9]* which serve as temporaries
for successive elaboration by the allocation logics.

Avoiding explicit register use, for temporaries, frees the programmer from one
of the most bothering tasks, letting the assembler decide which register
allocation to use.

For maximum performance, the programmer can still use direct register assignment
when needed, while letting the assembler manage all the rest.

To let the assembler manage arguments to functions and returned elements, syntax
was enhanced, to introduce such directives.

There is also a pending enhancement of the preprocessor, in order to add extra
functionalities like macro definitions and other directives.

4.2 - CALLING CONVENTIONS

The arguments of a function are explicitly defined using the ".param" keyword.
While the returned (if returned) element is always in register R1.

Caller-save registers are R[1-5] and A[1-5], while callee-save registers are
R[6-8] and A[6-8].

4.3 - SAMPLE FILES

Some sample .s files are in the main folder:
 testNewAssembler.s
 std_io.s
 std_conversion.s

The user can have a look to these examples.

------------------

If you feel this description incomplete, let me know.

I hope you will enjoy this playground for learning.
